package com.arithmetic.features.arithmetic.interview.dp;

import org.junit.Test;

/**
 * N个位置，1~N,N大于等于2，开始时机器人在其中的M位置，它可以向左或者右走。
 * 如果到了位置1，下一步只能是位置2；如果到了位置N,下一步只能是位置 N-1 。机器人走 K 步，最终来到位置 P 的总方法一共有多少种？
 *
 * @author tangsong
 * @date 2021/5/1 22:26
 */
public class RobotWays {

    /**
     * 暴力递归
     */
    @Test
    public void ways1() {
        int N = 5;
        int M = 2;
        int K = 2;
        int P = 2;
        int walk = walk(N, M, K, P);

        System.out.println(walk);
    }

    /**
     * 动态规划
     */
    @Test
    public void ways2() {
        int N = 5;
        int M = 2;
        int K = 2;
        int P = 2;
        int walk = ways_dp(N, M, K, P);

        System.out.println(walk);
    }

    /**
     * 暴力递归法
     *
     * N: 固定参数 长度， 1~N
     * M: 当前所在的位置
     * K: 剩余可走的步数
     * P: 最终的位置
     *
     *  返回值： 最终可以走到响应位置的方法数
     */
    private int walk(int N, int M, int K, int P) {
        if(N < 2 || P < 1 || M < 1 || K < 0 || P > N || M > N) {
            return 0;
        }
        if(K == 0) {
            // 当剩余可以走的步数等于0，则判断当前的位置
           return M == P ? 1 : 0;
        }
        int res = 0;
        if(M == 1) {
            // 如果当前在第一个位置，那么只能向右走一次
            res = walk(N, M + 1, K - 1, P);
        } else if(M == N) {
            // 如果当前在最后一个位置，那么只能先向左走一次
            res = walk(N, M - 1, K - 1, P);
        } else {
            // 当前可以既向左走，又可以向右走， 那么总的方法数，就是向左走可以到达目的地的方法数 + 向右走可以到达目的地的方法数
            res = walk(N, M + 1, K - 1, P) + walk(N, M - 1, K - 1, P);
        }

        return res;
    }


    /**
     * 动态规划
     *
     * 无后效性，一个递归状态的返回值与怎么到达这个状态的路径无关；
     * 1、寻找可变参数可以代表一个递归的状态，即哪些参数一旦确定，返回值就确定了；
     * 2、把可变参数的所有组合映射为一张表：1个可变参数就是一维表；2个可变参数就是二维表；
     * 3、最终答案要的是表中的哪个位置；
     * 4、根据递归过程的 base case,把表的最简单、不需要依赖其他位置的那些位置填好；
     * 5、根据递归的非 base case 部分，也就是表中普通位置需要怎么计算得到；
     *
     *  这个题目，那么就可以建立一个二维表，其中可变的参数就是 剩余步数 和 总的位置数
     *  最终位置可以视作是固定的，那么当剩余步数为0时，最终位置的方法就是1
     *  其中dp构建的二维数组中，横向的是剩余步数，列是每个不同的位置，那么可以剩余步数和位置填充的数据就是方法数
     *  其中根据暴力递归得到的计算逻辑进行填表，可以得到当前位置的方法数 = 上一行的前一列的方法数 + 上一行的下一列的方法数
     *
     *  因为可以确定刚开是的 （0, P） = 1，那么可以推到所有的位置的方法数，最终的方法数就是dp[K][M]
     *
     *
     */
    private int ways_dp(int N, int M, int K, int P) {
        if(N < 2 || P < 1 || M < 1 || K < 0 || P > N || M > N) {
            return 0;
        }
        // 定义二维数组，行 -> 剩余步数， 列 -> 总的位置数
        // 都进行+1, 因为都是从1开始不从0开始，N的定义就是1~N
        int[][] dp = new int[K+1][N+1];

        // 定义当剩余步数为0，位置为最终位置时，方法数为1
        dp[0][P] = 1;

        /**
         * 下面的操作是填充dp数组
         */
        // 总的步数
        for (int i = 1; i <= K; i++) {
            // 总的位置数
            for (int j = 1; j <= N; j++) {
                if(j == 1) {
                    // 当前的位置为第一个的时候, 填充时，根据上一行，第二个元素 = 上一行的下一个元素，因为上一个元素已经超出边界了
                    dp[i][j] = dp[i - 1][2];
                } else if(j == N) {
                    // 当前位置为最后一个我位置时，只计算上一行的前一列的方法数，因为上一行的下一列超过边界了
                    dp[i][j] = dp[i - 1][N - 1];
                } else {
                    // 否则，当前的位置的方法数 = 上一行的前一列 + 上一行的下一列
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];
                }
            }
        }
        // 已经将dp数组填充好了，
        // 那么最终的方法数就是根据剩余可以走的步数和当前的位置可以映射定位得到的数据
        return dp[K][M];
    }

}

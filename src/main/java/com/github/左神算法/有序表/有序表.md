# 有序表

## AVL Tree（平衡二叉树）

> 平衡二叉树是有序表的一种实现。相当于有序表是接口，平衡二叉树是实现类。有序表不仅仅只有平衡二叉树一种，还有SB树、红黑树、跳表、B树、B+树都是有序表，
> 有序表要求任何操作都是O(logN)时间复杂度

- 平衡二叉树：基于二叉排序树，所以也包含二叉排序的特点，它是一棵空树或者它的左右两个子树的的高度差不超过1，并且左右两颗子树都是一棵平衡二叉树

### 平衡二叉树的调整

- 不同的类型的树的调整方式：
    - LL：左子树的左子节点高度大，只进行一次右旋即可调整
    - LR：先对左子节点进行一次左旋，然后对当前节点进行一次右旋
    - RR：右子树的右子节点高度大，只需要进行一次左旋即可
    - RL：先对右子节点进行一次右旋，然后对当前节点进行一次左旋

> 如果一棵树同时满足LL、LR, 那么直接按照LL的方式调整，因为按照LR的方式调整之后可能并不会平衡


## Size Balance Tree(SBTree)

- SB树也是基于二叉搜索树的一种有序表，增删改查都是O(logN)的时间复杂度，和AVL树的不同搞是SB树是基于树的节点个数进行平衡的

- SB树判断是否平衡的条件  
  任何以叔叔节点为头的子树的节点个数不小于（大于等于）这个节点的任何一个侄子树的节点个数

### SB树的调整

- 不同类型的违规规则：
    - LL：当前节点的左子节点的左子节点个数多于当前节点的右子节点的个数
    - LR：当前节点的左子节点的右子节点个数多于当前节点的右子节点的个数
    - RR：当前节点的右子节点的右子节点个数多于当前节点的左子节点的个数
    - RL：当前节点的右子节点的左子节点个数多于当前节点的左子节点的个数

> 当前节点的左子节点的左子节点个数多于当前节点的右子节点 -> 可以理解为当前节点的左子节点的侄子节点的个数是否多于这个节点

- 不同类型的树的调整：
   - LL：以当前节点进行右旋（当前节点（根节点）就换了），然后对新当前节点、新当前节点的右子节点分别实行递归过程，即递归检查是否平衡的调整
   - LR：以当前节点的左子节点先进行左旋，然后以当前节点进行右旋，然后再对新当前节点的左子节点、新当前节点的右子节点、新当前节点分别进行递归检查调整平衡的过程
   - RR：以当前节点进行左旋，然后对新的当前节点、新当前节点的左子节点分别进行递归调整的过程
   - RL：以当前节点的右子节点先进行右旋，然后以当前节点进行左旋，然后再对新当前节点、新当前节点的左子节点、新当前节点的右子节点分别进行递归检查调整

> SB树的调整和AVL树部分一致，都是通过左旋和右旋进行调整，但是SB树的特点是，当旋转完成之后，还会对节点个数发生改变了的节点进行递归向下的检查是否平衡以及调整

> 这也是SB树可以相对好调整的原因，因为如果删除节点，那么可以先无需立即调整树，而是在添加节点的时候进行一次性的递归调整

## Skip List Tree(跳跃表)

- 跳表的特点
  O(logN)的时间复杂度，每次查询从最高层向底层开始查询，高层每经过一层，都加速了查询的效率。
  跳表的第一层保存的是最全的数据，每个数据必定都需要在第一层建立节点。   
> 跳表可以看做是一颗排序二叉树，每次查询的时候都是高层跳过节点，这样叶子节点就会跳过很多个

- 跳表每个节点的层数如何确定   
  通过roll骰子，保证每一层的层高的随机性，第一层N,第二层概率N/2，第三层N/4...，依次类推，那么层数越高概率就越小，
  所以就保证了高层的节点数是最少的。并且每次查询都是从高层开始查找，这样高层没跳过一个节点，底层就跳过很多个节点，加速了
  查询的效率。O(logN)的时间复杂度。
  
  
## 红黑树

- 红黑树特点：
  - 每个节点不是红就是黑
  - 头结点必须是黑节点，叶子节点也是黑节点
  - 两个红节点不能相邻
  - 每颗子树的任何一条到叶子节点的路径，黑节点的个数一样

- 红黑树的平衡条件：
  任何一个节点的较长的链和较短的链，长度不会超过2倍以上。因为较长的链肯定是红黑相间，而较短的链一定全是黑（这样才能保证黑色节点的个数相同）

> 目的是防止加减节点频繁的调整，而是在多个节点发生改变之后，一次整体调整，对IO消耗比较低
